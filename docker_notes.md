# Docker Notes

# Contents

[TOC]

# Learning Docker

### docker commit

```sh
# commit a container to an image with the docker commit subcommand
docker commit 472c96295678 learningdocker/ubuntu_wget
```

### launching a contained as a daemon

`docker run -d`

```sh
sudo docker run -d ubuntu /bin/bash -c "while true; do date; sleep 5; done"
```

`docker logs <container ID>` is used for viewing the output generated by daemon container.

### building images

#### Docker's integrated image building system

```dockerfile
FROM busybox:latest
CMD echo Hello World!!  
```

```sh
sudo docker build .  
sudo docker tag <image ID> busyboxplus
# build the image with an image name
sudo docker build -t busyboxplus .  
```



#### A quick overview of the syntax of Dockerfile

#### The Dockerfile build instructions

By default, the docker build subcommand uses Dockerfile located at the build context. However, with the `-f `option, the `docker build` subcommand allows us to specify an alternate Dockerfile at a different path or name.

```dockerfile
# Dockerfile to demonstrate the behavior of ENTRYPOINT

# Build from base image busybox:latest 
FROM busybox:latest

# Author: Dr. Peter 
MAINTAINER Dr. Peter <peterindia@gmail.com>

# Set entrypoint command 
ENTRYPOINT ["echo", "Dockerfile ENTRYPOINT demo"] 
```

##### ENTRYPOINT

```sh
docker build -t entrypoint-demo .
# launch the container
docker run entrypoint-demo
# output
Dockerfile ENTRYPOINT demo
# launch the container with additional arguments given to the docker sun subcommans
docker run entrypoint-demo with additional arguments
# output
Dockerfile ENTRYPOINT demo with additional arguments  
```

override the build time entry point application with the `--entrypoint` option and then launch a shell (/bin/sh)in the docker run subcommand

```sh
docker run -it --entrypoint="/bin/sh" entrypoint-demo
```

##### HEALTHCHECK

To monitor the health of containerized application.

```dockerfile
HEALTHCHECK [<option>] CMD <command>

HEALTHCHECK --interval=5m --timeout=3s
CMD curl -f http://localhost/ || exit 1 
```



#### A brief overview of the Docker image management

------

## Run the first container

```

```



```bash
docker run -d -p 80:80 httpd
# 从Docker Hub下载httpd镜像，镜像已经安装好Apache HTTP Server
# 启动httpd容器，并将容器的80端口映射到host的80端口
# 验证，在浏览器输入
http://[your ubuntu host IP]
```

Docker daemon是服务器组件，以Linux后台服务的方式运行。

```
systemctl status docker.service
```

默认配置下，Docker daemonz只能响应来自本地Host的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开TCP监听。

编辑配置文件

`/etc/systemd/system/multi-user.target.wants/docker.service`

在环境变量`ExecStart`后面添加`-H tcp://0.0.0.0`允许来自任意IP的客户端连接

重启Docker daemon

```sh
systemctl daemon-reload
systemctl restart docker.service

## 服务器IP为192.168.56.102，客户端在命令行里加上-H参数，即可与远程服务器通信
docker -H 192.168.56.102 info

# 运行容器
docker run -it ubuntu:16.04

apt-get update && apt-get install -y bzip2
tar -vcjf tienne_dir.tar.bz2 tienne_dir
docker build -t ubuntu-16-with-make-dockerfile .
# -t将新镜像命名为ubuntu-16-with-make-dockerfile
# 默认从build context查找Dockerfile，可以通过-f参数指定Dockerfile
# build context为当前目录，该目录下的所有文件和子目录都会被发送给Docker daemon
# missing表示无法获取IMAGE ID，通常从Docker Hub下载的镜像会有这个问题。
```

### Dockerfile example

```dockerfile
# ubuntu16.04安装vim
FROM ubuntu:16.04
RUN apt-get update && apt-get install -y vim
```

```dockerfile
###########################################       
# Dockerfile to build an Apache2 image
###########################################       
# Base image is Ubuntu       
FROM ubuntu:14.04
# Author: Dr. Peter
MAINTAINER Dr. Peter <peterindia@gmail.com>
# Install apache2 package
RUN apt-get update && apt-get install -y apache2 && apt-get clean 
```

#### docker commit

```sh
sudo docker commit 472c96295678 learningdocker/ubuntu_wget
```



## Dockerfile调试

如果Dockerfile由于某种原因执行到某个指令失败了，我们也将能够得到前一个指令成功执行构建出的镜像，这对调试Dockerfile非常有帮助。

`docker run -it <image ID>`启动镜像的一个容器

## Dockerfile常用指令

- FROM  指定base镜像

- MAINTAINER  设置镜像的作者，可以是任意的字符串

- COPY  src只能指定build context中的文件或目录

  ```dockerfile
  COPY src dest
  COPY ["src", "dest"]
  ```

- ADD  与COPY类似，从build context复制文件到镜像。不同的是，如果src是归档文件（tar、zip、tgz、xz等），文件会被自动解压到dest

- ENV  设置环境变量，环境变量可以被后面的指令使用

- EXPOSE  指定容器中的进程会监听某个端口

- VOLUME

- WORKDIR  为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录

- RUN  在容器中运行指定的命令

- CMD  容器启动时运行指定的命令

- ENTRYPOINT  设置容器启动时运行的命令

Dockerfile中可以有多个ENTRYPOINT指令，但只有最后一个生效。CMD或docker run之后的参数会被当作参数传递给ENTRYPOINT。

```dockerfile
# tienne Dockerfile
FROM busybox
MAINTAINER Tienne
WORKDIR /testdir
RUN touch tmpfile1
COPY ["tmpfile2", "."]
ADD ["bunch.tar.gz", "."]
ENV WELCOME "Welcome to tienne world!"
```

## RUN vs CMD vs ENTRYPOINT

**RUN**  执行命令并创建新的镜像层，经常用于安装软件包

**CMD**  设置容器启动后默认执行的命令及其参数，但能够被`docker run`后面跟的命令行参数替换

**ENTRYPOINT**  配置容器启动时运行的命令

Shell格式，底层会调用/bin/sh -c [command]

```sh
# <instruction> <command>
RUN apt-get install python3
CMD echo "Hello world"
ENTRYPOINT echo "Hello world"

```

Exec格式，直接调用[command],不会被shell解析

```sh
# <instruction> ["executable", "param1", "param2", ...]
RUN ["apt-get", "install", "python3"]
CMD ["/bin/echo", "Hello world"]
ENTRYPOINT ["/bin/echo", "Hello world"]
```

==CMD和ENTRYPOINT推荐使用Exec格式，因为指令可读性更强，更容易理解。RUN则两种格式都可以。==

```dockerfile
ENV name Cloud Man 
ENTRYPOINT ["/bin/echo", "Hello, $name"]
# 输出
Hello, $name

ENV name Cloud Man
ENTRYPOINT ["/bin/sh", "-c", "echo Hello, $name"]
# 输出
Hello, Cloud Man
```

### RUN

```dockerfile
# Sheel 格式
# apt-get update和apt-get install被放在一个RUN指令中执行，这样能够保证每次安装的是最新的包。如果apt-get install在单独的RUN中执行，则会使用apt-get update创建镜像层，而这一层可能是很久以前缓存的
RUN apt-get update && apt-get install -y \bzr\cvs\git\mercurial\subversion

# Exec格式
RUN ["executable", "param1","param2"]
```

### CMD

会在容器启动且docker tun没有指定其他命令时运行。

如果docker run指定了其他命令，CMD指定的默认命令将被忽略

如果Dockerfile中有多个CMD指令，只有最后一个CMD有效

```dockerfile
# exec
CMD ["executable", "param1", "param2"]
# 为ENTRYPOINT提供额外的参数，要与exce格式的ENTRYPOINT指令配合使用
CMD["param1", "param2"]
# shell
CMD command param1 param2
```

### ENTRYPOINT

不会被忽略，一定会被执行，即使运行docker run时指定了其他命令。

```dockerfile
# exec, recommend
ENTRYPOINT ["executable","param1", "param2"]
# Shell
ENTRYPOINT command param1 param2
```

- exec
- shell

exec同时可通过CMD提供额外的参数，ENTRYPOINT中的参数始终会被使用，CMD的额外参数可以在容器启动时动态替换掉

```dockerfile
ENTRYPOINT ["/bin/echo", "Hello"]
CMD ["world"]
# docker run -it [image]启动，输出
Hello world
# docker run -it [image] CloudMan启动，输出为：
Hello CloudMan
```

==Shell格式会忽略任何CMD或docker run提供的参数。==

## 本地registry

```sh
docker run -d -p 5000:5000 -v /myregistry:/var/lib/registry registry:2
```

## 运行容器

```sh
# 
docker run ubuntu /bin/bash -C "while true ; do sleep 1; done"
# 加上参数-d以后台方式启动容器
docker run -d ubuntu /bin/bash -C "while true ; do sleep 1; done"
```

### 两种进入容器的方法

**docker attach**  不会启动新的进程

attach到容器启动命令的终端。通过Ctrl+p，然后Ctrl+q，退出attach终端。如果只为了查看启动命令的输出，可以使用`docker logs -f <container ID>`

**docker exec**  进入相同的容器。打开新的终端，可以启动新的进程。

```sh
docker exec -it <container ID> bash
# 
exit
```

**服务类容器**以daemon的方式运行，对外提供服务，通过`-d`以后台方式启动。如果要排查问题，可以通过`exex -it`进入容器。

工具类容器通常以`run -it`方式运行。



## docker machine

```sh
curl -L https://github.com/docker/machine/releases/download/v0.9.0/docker-machine-`uname -s`-`uname -m` >/tmp/docker-machine 
&& chmod +x /tmp/docker-machine 
&& sudo cp /tmp/docker-machine /usr/local/bin/docker-machine
```

